{
    "title": "OOPs in python",
    "author": {
        "name": "Nandigam Hari Krishna",
        "profile_link": "https://medium.com/@hari12.nhk?source=post_page---byline--59dd7ab8d3a7---------------------------------------"
    },
    "date": "Jul 10, 2024",
    "reading_time": "5 min read",
    "sections": [
        {
            "heading": "Object vs Class",
            "content": "Class -> It is a template/blueprint of how the object will look like\n\nIn python we use class keyword to create classes.\n\n```python\n# Ex: (Linked list node)\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n        self.prev = None\n\n# Variables in the class are called attributes -> Attributes are always public\n\n# Define a class named Car\nclass Shoe:\n    # Class attributes\n    brand = \"Nike\"\n    model = \"Air Jordan's\"\n\n# Accessing class attributes using the dot (.) operator\nprint(Shoe.brand)\nprint(Shoe.model)\n\n# Create an instance/object of the Car class\nmy_shoe = Shoe()\n\n# Accessing class attributes through an instance\nprint(my_shoe.brand)\nprint(my_shoe.model)\n\n# In the above examples Shoe is Class and my_show is object\n```\n\n```\nNike\nAir Jordan's\nNike\nAir Jordan's\n```"
        },
        {
            "heading": "Encapsulation",
            "content": "Encapsulation is used to hide data and operate the data within the class\n\n- In python there is no strict enforcement of encapsulation\n\n\\- It is purely trust based\n\n\\- In python if we define a variable with “\\_” (underscore) at the start, it should be understood that\n\n\\- The other developers should respect the guidelines and not access those variables\n\n\\- Unlike other languages like C++ we cannot enforce strict policies for encapsulation\n\n```python\nclass Shoe:\n    def __init__(self, brand, model, size):\n        self.__brand = brand  # Private variable\n        self.__model = model  # Private variable\n        self.__size = size    # Private variable\n\n    def get_info(self):\n        return f\"{self.__brand} {self.__model} (Size: {self.__size})\"\n\n    def set_size(self, size):\n        if size > 0:  # Shoe size should be positive # This is like enforcing rules\n            self.__size = size\n        else:\n            print(\"Invalid size\")\n\n# Create a Shoe object\nmy_shoe = Shoe(\"Nike\", \"Air Max\", 42)\nprint(my_shoe.get_info())  # Output: Nike Air Max (Size: 42)\nmy_shoe.set_size(43)\nprint(my_shoe.get_info())  # Output: Nike Air Max (Size: 43)\n\n# below will throw error\n# print(my_shoe.__brand)\n\n# We are using __branch because it mangles the name internally and it is difficult to get the mangled name.\n```\n\n```\nNike Air Max (Size: 42)\nNike Air Max (Size: 43)\n```"
        },
        {
            "heading": "Inheritance",
            "content": "Inheritance is a mechanism where a new class inherits properties and behavior (methods) from an existing class. This promotes code reuse and establishes a relationship between classes.\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def describe(self):\n        return f\"This animal is named {self.name} and is {self.age} years old.\"\n\nclass Mammal(Animal):\n    def __init__(self, name, age, fur_color):\n        super().__init__(name, age)\n        self.fur_color = fur_color\n\n    def describe(self):\n        return super().describe() + f\" It has {self.fur_color} fur.\"\n\nclass Dog(Mammal):\n    def __init__(self, name, age, fur_color, breed):\n        super().__init__(name, age, fur_color)\n        self.breed = breed\n\n    def describe(self):\n        return super().describe() + f\" It's a {self.breed}.\"\n\nclass Cat(Mammal):\n    def __init__(self, name, age, fur_color, is_indoor):\n        super().__init__(name, age, fur_color)\n        self.is_indoor = is_indoor\n\n    def describe(self):\n        indoor_status = \"an indoor\" if self.is_indoor else \"an outdoor\"\n        return super().describe() + f\" It's {indoor_status} cat.\"\n\n# Using the classes\ndog = Dog(\"Buddy\", 5, \"brown\", \"Labrador\")\ncat = Cat(\"Whiskers\", 3, \"white\", True)\n\nprint(dog.describe())\n\nprint(cat.describe())\n```\n\n```\nThis animal is named Buddy and is 5 years old. It has brown fur. It's a Labrador.\nThis animal is named Whiskers and is 3 years old. It has white fur. It's an indoor cat.\n```"
        },
        {
            "heading": "Abstraction",
            "content": "Abstraction in programming is the concept of hiding the complex implementation details and showing only the necessary features of an object.\n\n```python\nfrom abc import ABC, abstractmethod\n\n# In python we use super() to inherit from parent class\n# Base class\nclass Animal(ABC):\n    @abstractmethod\n    def sound(self):\n        pass\n\n# Derived classes\nclass Dog(Animal):\n    def sound(self):\n        return \"Bark\"\n\nclass Cat(Animal):\n    def sound(self):\n        return \"Meow\"\n\n# Function that uses polymorphism\ndef make_sound(animal):\n    print(animal.sound())\n\n# Instantiate objects\ndog = Dog()\ncat = Cat()\n\nanimals = [dog, cat]\nfor animal in animals:\n    make_sound(animal)\n\n\n# In the above example:\n# abstract base class (Animal), you establish a uniform interface for\n# all types of accounts\n# This ensures that all Animal types share the same set of interface Ex: sound\n\n# By using @abstractmethod, you enforce that all subclasses must implement the abstract methods,\n# providing a clear contract that must be followed.\n```\n\n```\nBark\nMeow\n```"
        },
        {
            "heading": "Polymorphism",
            "content": "Polymorphism in programming refers to the ability to present the same interface for different types of objects.\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def describe(self):\n        return f\"This animal is named {self.name} and is {self.age} years old.\"\n\n    @abstractmethod\n    def sound(self):\n        pass\n\nclass Mammal(Animal):\n    def __init__(self, name, age, fur_color):\n        super().__init__(name, age)\n        self.fur_color = fur_color\n\n    def describe(self):\n        return super().describe() + f\" It has {self.fur_color} fur.\"\n\nclass Dog(Mammal):\n    def __init__(self, name, age, fur_color, breed):\n        super().__init__(name, age, fur_color)\n        self.breed = breed\n\n    def sound(self):\n        return \"Woof!\"\n\n    def describe(self):\n        return super().describe() + f\" It's a {self.breed}.\"\n\nclass Cat(Mammal):\n    def __init__(self, name, age, fur_color, is_indoor):\n        super().__init__(name, age, fur_color)\n        self.is_indoor = is_indoor\n\n    def sound(self):\n        return \"Meow!\"\n\n    def describe(self):\n        indoor_status = \"an indoor\" if self.is_indoor else \"an outdoor\"\n        return super().describe() + f\" It's {indoor_status} cat.\"\n\nclass Bird(Animal):\n    def __init__(self, name, age, wing_span):\n        super().__init__(name, age)\n        self.wing_span = wing_span\n\n    def sound(self):\n        return \"Chirp!\"\n\n    def describe(self):\n        return super().describe() + f\" It has a wing span of {self.wing_span} cm.\"\n\n# Polymorphic function\ndef animal_sound(animal):\n    print(f\"{animal.name} says: {animal.sound()}\")\n\ndef animal_description(animal):\n    print(animal.describe())\n\n# Create instances of different animals\ndog = Dog(\"Buddy\", 5, \"brown\", \"Labrador\")\ncat = Cat(\"Whiskers\", 3, \"white\", True)\nbird = Bird(\"Tweety\", 2, 15)\n\n# List of different animal objects\nanimals = [dog, cat, bird]\n\n# Demonstrate polymorphism\nfor animal in animals:\n    animal_sound(animal)\n    animal_description(animal)\n    print()  # Empty line for readability\n```\n\n```\nBuddy says: Woof!\nThis animal is named Buddy and is 5 years old. It has brown fur. It's a Labrador.\n\nWhiskers says: Meow!\nThis animal is named Whiskers and is 3 years old. It has white fur. It's an indoor cat.\n\nTweety says: Chirp!\nThis animal is named Tweety and is 2 years old. It has a wing span of 15 cm.\n```"
        }
    ]
}