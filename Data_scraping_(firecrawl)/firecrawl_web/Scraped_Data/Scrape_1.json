{
    "headings": [
        {
            "level": 1,
            "text": "OOPs in python"
        },
        {
            "level": 2,
            "text": "Object vs Class"
        },
        {
            "level": 2,
            "text": "Encapsulation"
        },
        {
            "level": 2,
            "text": "Inheritance"
        },
        {
            "level": 2,
            "text": "Abstraction"
        },
        {
            "level": 2,
            "text": "Polymorphism"
        }
    ],
    "paragraphs": [
        {
            "text": "Class -> It is a template/blueprint of how the object will look like"
        },
        {
            "text": "Encapsulation is used to hide data and operate the data within the class"
        },
        {
            "text": "Inheritance is a mechanism where a new class inherits properties and behavior (methods) from an existing class. This promotes code reuse and establishes a relationship between classes."
        },
        {
            "text": "Abstraction in programming is the concept of hiding the complex implementation details and showing only the necessary features of an object."
        },
        {
            "text": "Polymorphism in programming refers to the ability to present the same interface for different types of objects."
        }
    ],
    "codeBlocks": [
        {
            "language": "python",
            "code": "# Ex: (Linked list node)\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n        self.prev = None\n\n# Variables in the class are called attributes -> Attributes are always public\n\n# Define a class named Car\nclass Shoe:\n    # Class attributes\n    brand = \"Nike\"\n    model = \"Air Jordan's\"\n\n# Accessing class attributes using the dot (.) operator\nprint(Shoe.brand)\nprint(Shoe.model)\n\n# Create an instance/object of the Car class\nmy_shoe = Shoe()\n\n# Accessing class attributes through an instance\nprint(my_shoe.brand)\nprint(my_shoe.model)\n\n# In the above examples Shoe is Class and my_show is object"
        },
        {
            "language": "python",
            "code": "class Shoe:\n    def __init__(self, brand, model, size):\n        self.__brand = brand  # Private variable\n        self.__model = model  # Private variable\n        self.__size = size    # Private variable\n\n    def get_info(self):\n        return f\"{self.__brand} {self.__model} (Size: {self.__size})\"\n\n    def set_size(self, size):\n        if size > 0:  # Shoe size should be positive # This is like enforcing rules\n            self.__size = size\n        else:\n            print(\"Invalid size\")\n\n# Create a Shoe object\nmy_shoe = Shoe(\"Nike\", \"Air Max\", 42)\nprint(my_shoe.get_info())  # Output: Nike Air Max (Size: 42)\nmy_shoe.set_size(43)\nprint(my_shoe.get_info())  # Output: Nike Air Max (Size: 43)\n\n# below will throw error\n# print(my_shoe.__brand)\n\n# We are using __branch because it mangles the name internally and it is difficult to get the mangled name."
        },
        {
            "language": "python",
            "code": "from abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def describe(self):\n        return f\"This animal is named {self.name} and is {self.age} years old.\"\n\nclass Mammal(Animal):\n    def __init__(self, name, age, fur_color):\n        super().__init__(name, age)\n        self.fur_color = fur_color\n\n    def describe(self):\n        return super().describe() + f\" It has {self.fur_color} fur.\"\n\nclass Dog(Mammal):\n    def __init__(self, name, age, fur_color, breed):\n        super().__init__(name, age, fur_color)\n        self.breed = breed\n\n    def describe(self):\n        return super().describe() + f\" It's a {self.breed}.\"\n\nclass Cat(Mammal):\n    def __init__(self, name, age, fur_color, is_indoor):\n        super().__init__(name, age, fur_color)\n        self.is_indoor = is_indoor\n\n    def describe(self):\n        indoor_status = \"an indoor\" if self.is_indoor else \"an outdoor\"\n        return super().describe() + f\" It's {indoor_status} cat.\"\n\n# Using the classes\ndog = Dog(\"Buddy\", 5, \"brown\", \"Labrador\")\ncat = Cat(\"Whiskers\", 3, \"white\", True)\n\nprint(dog.describe())\n\nprint(cat.describe())"
        },
        {
            "language": "python",
            "code": "from abc import ABC, abstractmethod\n\n# In python we use super() to inherit from parent class\n# Base class\nclass Animal(ABC):\n    @abstractmethod\n    def sound(self):\n        pass\n\n# Derived classes\nclass Dog(Animal):\n    def sound(self):\n        return \"Bark\"\n\nclass Cat(Animal):\n    def sound(self):\n        return \"Meow\"\n\n# Function that uses polymorphism\ndef make_sound(animal):\n    print(animal.sound())\n\n# Instantiate objects\ndog = Dog()\ncat = Cat()\n\nanimals = [dog, cat]\nfor animal in animals:\n    make_sound(animal)\n\n\n# In the above example:\n# abstract base class (Animal), you establish a uniform interface for\n# all types of accounts\n# This ensures that all Animal types share the same set of interface Ex: sound\n\n# By using @abstractmethod, you enforce that all subclasses must implement the abstract methods,\n# providing a clear contract that must be followed."
        },
        {
            "language": "python",
            "code": "from abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def describe(self):\n        return f\"This animal is named {self.name} and is {self.age} years old.\"\n\n    @abstractmethod\n    def sound(self):\n        pass\n\nclass Mammal(Animal):\n    def __init__(self, name, age, fur_color):\n        super().__init__(name, age)\n        self.fur_color = fur_color\n\n    def describe(self):\n        return super().describe() + f\" It has {self.fur_color} fur.\"\n\nclass Dog(Mammal):\n    def __init__(self, name, age, fur_color, breed):\n        super().__init__(name, age, fur_color)\n        self.breed = breed\n\n    def sound(self):\n        return \"Woof!\"\n\n    def describe(self):\n        return super().describe() + f\" It's a {self.breed}.\"\n\nclass Cat(Mammal):\n    def __init__(self, name, age, fur_color, is_indoor):\n        super().__init__(name, age, fur_color)\n        self.is_indoor = is_indoor\n\n    def sound(self):\n        return \"Meow!\"\n\n    def describe(self):\n        indoor_status = \"an indoor\" if self.is_indoor else \"an outdoor\"\n        return super().describe() + f\" It's {indoor_status} cat.\"\n\nclass Bird(Animal):\n    def __init__(self, name, age, wing_span):\n        super().__init__(name, age)\n        self.wing_span = wing_span\n\n    def sound(self):\n        return \"Chirp!\"\n\n    def describe(self):\n        return super().describe() + f\" It has a wing span of {self.wing_span} cm.\"\n\n# Polymorphic function\ndef animal_sound(animal):\n    print(f\"{animal.name} says: {animal.sound()}\")\n\ndef animal_description(animal):\n    print(animal.describe())\n\n# Create instances of different animals\ndog = Dog(\"Buddy\", 5, \"brown\", \"Labrador\")\ncat = Cat(\"Whiskers\", 3, \"white\", True)\nbird = Bird(\"Tweety\", 2, 15)\n\n# List of different animal objects\nanimals = [dog, cat, bird]\n\n# Demonstrate polymorphism\nfor animal in animals:\n    animal_sound(animal)\n    animal_description(animal)\n    print()  # Empty line for readability"
        }
    ]
}